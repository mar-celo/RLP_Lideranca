{"version":3,"sources":["node_modules/browser-pack/_prelude.js","theSrc/scripts/plotly.js","theSrc/scripts/widgetdefinition.js"],"names":["r","e","n","t","o","i","f","c","require","u","a","Error","code","p","exports","call","length","1","module","_widgetdefinition","HTMLWidgets","widget","_widgetdefinition2","default","widgetDefinition","name","type","initialize","el","width","height","resize","instance","autosize","Plotly","relayout","renderValue","x","lay","layout","crosstalk","var","set","highlight","window","PLOTLYENV","BASE_URL","base_url","persistent","onmousemove","event","shiftKey","persistentShift","graphDiv","document","getElementById","id","setAttribute","addPostRenderHandler","modebars","querySelectorAll","style","zIndex","selectize","dynamic","plotly","pickerDiv","flex","createElement","class","pickerInput","placeholder","pickerLabel","for","innerHTML","appendChild","ids","Object","keys","container","label","group","selectDiv","select","multiple","parentElement","insertBefore","picker","$","colors","color","opts","value","showColour","palette","allowedCols","join","colourpicker","changeDelay","grps","ctGroups","on","eventDataWithKey","eventData","undefined","hasOwnProperty","points","map","pt","obj","curveNumber","pointNumber","y","z","customdata","attrsToAttach","trace","data","_isSimpleKey","key","attr","Array","isArray","pointNumbers","idx","config","cloud","modeBarButtonsToRemove","push","self","top","isPlainObject","JSON","parse","stringify","plot","transition","react","purge","newPlot","catch","then","shinyMode","Shiny","addCustomMessageHandler","msg","gd","method","args","concat","apply","mapboxIDs","_fullLayout","_subplots","mapbox","_fitBounds","_subplot","fitBounds","bounds","options","eventClearMap","eventDataFunctionMap","legendEventData","d","legendgroup","legendgrps","traces","setInputValue","plotly_deselect","plotly_unhover","plotly_doubleclick","evt","input","source","priority","plotly_click","plotly_sunburstclick","plotly_hover","plotly_selected","plotly_selecting","plotly_brushed","range","lassoPoints","plotly_brushing","plotly_legendclick","plotly_legenddoubleclick","plotly_clickannotation","fullAnnotation","shinyEvents","eventDataPreProcessor","traceManager","TraceManager","allSets","curveIdx","newSet","indexOf","selection","SelectionHandle","FilterHandle","removeBrush","updateFilter","prototype","diff","this","filter","oldValue","selectionHistory","get","receiverID","plotlySelectionColour","ev","updateSelection","clear","addItems","close","selectizeID","turnOn","selectedKeys","keysBySet","keyFlat","ptNum","_isNestedKey","pointsToKeys","sender","debounce","func","wait","immediate","timeout","context","arguments","callNow","clearTimeout","setTimeout","off","items","searchField","valueField","labelField","maxItems","find","currentItems","groupSelections","removeItem","newItems","origData","origOpacity","opacity","getMatchFunc","findNestedMatches","findSimpleMatches","findMatches","haystack","needleSet","matches","forEach","every","val","toString","getPrototypeOf","subsetArrayAttrs","indices","newObj","k","charAt","transform","arr","result","subsetArray","outlines","remove","matchFunc","redraw","nNewTraces","tracesToRemove","_isCrosstalkTrace","deleteTraces","restyle","selectionColour","_fullData","extend","selected","marker","line","textfont","fillcolor","_originalIndex","_newIndex","addTraces","_hash","_transitionData","_frameHash","_frames","newIndices","j","tr","ctr","nFrameTraces","frameTrace","tracesToDim","opacities","sets","opacityDim","selectedpoints"],"mappings":"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","file":"plotly.js","sourcesContent":["(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c=\"function\"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error(\"Cannot find module '\"+i+\"'\");throw a.code=\"MODULE_NOT_FOUND\",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u=\"function\"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()","import widgetDefinition from './widgetdefinition'\n\nHTMLWidgets.widget(widgetDefinition)\n","const widgetDefinition = {\n  name: \"plotly\",\n  type: \"output\",\n\n  initialize: function(el, width, height) {\n    return {};\n  },\n\n  resize: function(el, width, height, instance) {\n    if (instance.autosize) {\n      var width = instance.width || width;\n      var height = instance.height || height;\n      Plotly.relayout(el, {width: width, height: height});\n    }\n  },  \n  \n  renderValue: function(el, x, instance) {\n    \n    // Plotly.relayout() mutates the plot input object, so make sure to \n    // keep a reference to the user-supplied width/height *before*\n    // we call Plotly.plot();\n    var lay = x.layout || {};\n    instance.width = lay.width;\n    instance.height = lay.height;\n    instance.autosize = lay.autosize || true;\n    \n    /* \n    / 'inform the world' about highlighting options this is so other\n    / crosstalk libraries have a chance to respond to special settings \n    / such as persistent selection. \n    / AFAIK, leaflet is the only library with such intergration\n    / https://github.com/rstudio/leaflet/pull/346/files#diff-ad0c2d51ce5fdf8c90c7395b102f4265R154\n    */\n    var ctConfig = crosstalk.var('plotlyCrosstalkOpts').set(x.highlight);\n      \n    if (typeof(window) !== \"undefined\") {\n      // make sure plots don't get created outside the network (for on-prem)\n      window.PLOTLYENV = window.PLOTLYENV || {};\n      window.PLOTLYENV.BASE_URL = x.base_url;\n      \n      // Enable persistent selection when shift key is down\n      // https://stackoverflow.com/questions/1828613/check-if-a-key-is-down\n      var persistOnShift = function(e) {\n        if (!e) window.event;\n        if (e.shiftKey) { \n          x.highlight.persistent = true; \n          x.highlight.persistentShift = true;\n        } else {\n          x.highlight.persistent = false; \n          x.highlight.persistentShift = false;\n        }\n      };\n      \n      // Only relevant if we haven't forced persistent mode at command line\n      if (!x.highlight.persistent) {\n        window.onmousemove = persistOnShift;\n      }\n    }\n\n    var graphDiv = document.getElementById(el.id);\n\n    // Used by Displayr to determine when widget is ready to be snapshot for testing\n    graphDiv.setAttribute(\"rhtmlwidget-status\", \"loading\");\n    \n    // TODO: move the control panel injection strategy inside here...\n    HTMLWidgets.addPostRenderHandler(function() {\n      \n      // lower the z-index of the modebar to prevent it from highjacking hover\n      // (TODO: do this via CSS?)\n      // https://github.com/ropensci/plotly/issues/956\n      // https://www.w3schools.com/jsref/prop_style_zindex.asp\n      var modebars = document.querySelectorAll(\".js-plotly-plot .plotly .modebar\");\n      for (var i = 0; i < modebars.length; i++) {\n        modebars[i].style.zIndex = 1;\n      }\n    });\n      \n      // inject a \"control panel\" holding selectize/dynamic color widget(s)\n    if ((x.selectize || x.highlight.dynamic) && !instance.plotly) {\n      var flex = document.createElement(\"div\");\n      flex.class = \"plotly-crosstalk-control-panel\";\n      flex.style = \"display: flex; flex-wrap: wrap\";\n      \n      // inject the colourpicker HTML container into the flexbox\n      if (x.highlight.dynamic) {\n        var pickerDiv = document.createElement(\"div\");\n        \n        var pickerInput = document.createElement(\"input\");\n        pickerInput.id = el.id + \"-colourpicker\";\n        pickerInput.placeholder = \"asdasd\";\n        \n        var pickerLabel = document.createElement(\"label\");\n        pickerLabel.for = pickerInput.id;\n        pickerLabel.innerHTML = \"Brush color&nbsp;&nbsp;\";\n        \n        pickerDiv.appendChild(pickerLabel);\n        pickerDiv.appendChild(pickerInput);\n        flex.appendChild(pickerDiv);\n      }\n      \n      // inject selectize HTML containers (one for every crosstalk group)\n      if (x.selectize) {\n        var ids = Object.keys(x.selectize);\n        \n        for (var i = 0; i < ids.length; i++) {\n          var container = document.createElement(\"div\");\n          container.id = ids[i];\n          container.style = \"width: 80%; height: 10%\";\n          container.class = \"form-group crosstalk-input-plotly-highlight\";\n          \n          var label = document.createElement(\"label\");\n          label.for = ids[i];\n          label.innerHTML = x.selectize[ids[i]].group;\n          label.class = \"control-label\";\n          \n          var selectDiv = document.createElement(\"div\");\n          var select = document.createElement(\"select\");\n          select.multiple = true;\n          \n          selectDiv.appendChild(select);\n          container.appendChild(label);\n          container.appendChild(selectDiv);\n          flex.appendChild(container);\n        }\n      }\n      \n      // finally, insert the flexbox inside the htmlwidget container,\n      // but before the plotly graph div\n      graphDiv.parentElement.insertBefore(flex, graphDiv);\n      \n      if (x.highlight.dynamic) {\n        var picker = $(\"#\" + pickerInput.id);\n        var colors = x.highlight.color || [];\n        // TODO: let users specify options?\n        var opts = {\n          value: colors[0],\n          showColour: \"both\",\n          palette: \"limited\",\n          allowedCols: colors.join(\" \"),\n          width: \"20%\",\n          height: \"10%\"\n        };\n        picker.colourpicker({changeDelay: 0});\n        picker.colourpicker(\"settings\", opts);\n        picker.colourpicker(\"value\", opts.value);\n        // inform crosstalk about a change in the current selection colour\n        var grps = x.highlight.ctGroups || [];\n        for (var i = 0; i < grps.length; i++) {\n          crosstalk.group(grps[i]).var('plotlySelectionColour')\n            .set(picker.colourpicker('value'));\n        }\n        picker.on(\"change\", function() {\n          for (var i = 0; i < grps.length; i++) {\n            crosstalk.group(grps[i]).var('plotlySelectionColour')\n              .set(picker.colourpicker('value'));\n          }\n        });\n      }\n    }\n    \n    // remove \"sendDataToCloud\", unless user has specified they want it\n    x.config = x.config || {};\n    if (!x.config.cloud) {\n      x.config.modeBarButtonsToRemove = x.config.modeBarButtonsToRemove || [];\n      x.config.modeBarButtonsToRemove.push(\"sendDataToCloud\");\n    }\n    \n    // if the object was passed in from another window, plotly will falsely think it isn't a \"plain object\"\n    // to get around this, we have to create a deep copy of the object\n    if (inIframe() && !isPlainObject(x))\n       x = JSON.parse(JSON.stringify(x))\n\n    // if no plot exists yet, create one with a particular configuration\n    if (!instance.plotly) {\n      \n      var plot = Plotly.newPlot(graphDiv, x);\n      instance.plotly = true;\n      \n    } else if (x.layout.transition) {\n      \n      var plot = Plotly.react(graphDiv, x);\n    \n    } else {\n      \n      // this is essentially equivalent to Plotly.newPlot(), but avoids creating \n      // a new webgl context\n      // https://github.com/plotly/plotly.js/blob/2b24f9def901831e61282076cf3f835598d56f0e/src/plot_api/plot_api.js#L531-L532\n\n      // TODO: restore crosstalk selections?\n      Plotly.purge(graphDiv);\n      // TODO: why is this necessary to get crosstalk working?\n      graphDiv.data = undefined;\n      graphDiv.layout = undefined;\n      var plot = Plotly.newPlot(graphDiv, x);\n    }\n    \n    // Trigger plotly.js calls defined via `plotlyProxy()`\n    plot.catch(function() {\n      // Used by Displayr to determine when widget is ready to be snapshot for testing\n      graphDiv.setAttribute(\"rhtmlwidget-status\", \"ready\");\n    }).then(function() {\n      // Used by Displayr to determine when widget is ready to be snapshot for testing\n      graphDiv.setAttribute(\"rhtmlwidget-status\", \"ready\");\n      if (HTMLWidgets.shinyMode) {\n        Shiny.addCustomMessageHandler(\"plotly-calls\", function(msg) {\n          var gd = document.getElementById(msg.id);\n          if (!gd) {\n            throw new Error(\"Couldn't find plotly graph with id: \" + msg.id);\n          }\n          // This isn't an official plotly.js method, but it's the only current way to \n          // change just the configuration of a plot \n          // https://community.plot.ly/t/update-config-function/9057\n          if (msg.method == \"reconfig\") {\n            Plotly.react(gd, gd.data, gd.layout, msg.args);\n            return;\n          }\n          if (!Plotly[msg.method]) {\n            throw new Error(\"Unknown method \" + msg.method);\n          }\n          var args = [gd].concat(msg.args);\n          Plotly[msg.method].apply(null, args);\n        });\n      }\n      \n      // plotly's mapbox API doesn't currently support setting bounding boxes\n      // https://www.mapbox.com/mapbox-gl-js/example/fitbounds/\n      // so we do this manually...\n      // TODO: make sure this triggers on a redraw and relayout as well as on initial draw\n      var mapboxIDs = graphDiv._fullLayout._subplots.mapbox || [];\n      for (var i = 0; i < mapboxIDs.length; i++) {\n        var id = mapboxIDs[i];\n        var mapOpts = x.layout[id] || {};\n        var args = mapOpts._fitBounds || {};\n        if (!args) {\n          continue;\n        }\n        var mapObj = graphDiv._fullLayout[id]._subplot.map;\n        mapObj.fitBounds(args.bounds, args.options);\n      }\n      \n    });\n    \n    // Attach attributes (e.g., \"key\", \"z\") to plotly event data\n    function eventDataWithKey(eventData) {\n      if (eventData === undefined || !eventData.hasOwnProperty(\"points\")) {\n        return null;\n      }\n      return eventData.points.map(function(pt) {\n        var obj = {\n          curveNumber: pt.curveNumber, \n          pointNumber: pt.pointNumber, \n          x: pt.x,\n          y: pt.y\n        };\n        \n        // If 'z' is reported with the event data, then use it!\n        if (pt.hasOwnProperty(\"z\")) {\n          obj.z = pt.z;\n        }\n        \n        if (pt.hasOwnProperty(\"customdata\")) {\n          obj.customdata = pt.customdata;\n        }\n        \n        /* \n          TL;DR: (I think) we have to select the graph div (again) to attach keys...\n          \n          Why? Remember that crosstalk will dynamically add/delete traces \n          (see traceManager.prototype.updateSelection() below)\n          For this reason, we can't simply grab keys from x.data (like we did previously)\n          Moreover, we can't use _fullData, since that doesn't include \n          unofficial attributes. It's true that click/hover events fire with \n          pt.data, but drag events don't...\n        */\n        var gd = document.getElementById(el.id);\n        var trace = gd.data[pt.curveNumber];\n        \n        if (!trace._isSimpleKey) {\n          var attrsToAttach = [\"key\"];\n        } else {\n          // simple keys fire the whole key\n          obj.key = trace.key;\n          var attrsToAttach = [];\n        }\n        \n        for (var i = 0; i < attrsToAttach.length; i++) {\n          var attr = trace[attrsToAttach[i]];\n          if (Array.isArray(attr)) {\n            if (typeof pt.pointNumber === \"number\") {\n              obj[attrsToAttach[i]] = attr[pt.pointNumber];\n            } else if (Array.isArray(pt.pointNumber)) {\n              obj[attrsToAttach[i]] = attr[pt.pointNumber[0]][pt.pointNumber[1]];\n            } else if (Array.isArray(pt.pointNumbers)) {\n              obj[attrsToAttach[i]] = pt.pointNumbers.map(function(idx) { return attr[idx]; });\n            }\n          }\n        }\n        return obj;\n      });\n    }\n    \n    \n    var legendEventData = function(d) {\n      // if legendgroup is not relevant just return the trace\n      var trace = d.data[d.curveNumber];\n      if (!trace.legendgroup) return trace;\n      \n      // if legendgroup was specified, return all traces that match the group\n      var legendgrps = d.data.map(function(trace){ return trace.legendgroup; });\n      var traces = [];\n      for (i = 0; i < legendgrps.length; i++) {\n        if (legendgrps[i] == trace.legendgroup) {\n          traces.push(d.data[i]);\n        }\n      }\n      \n      return traces;\n    };\n\n    \n    // send user input event data to shiny\n    if (HTMLWidgets.shinyMode && Shiny.setInputValue) {\n      \n      // Some events clear other input values\n      // TODO: always register these?\n      var eventClearMap = {\n        plotly_deselect: [\"plotly_selected\", \"plotly_selecting\", \"plotly_brushed\", \"plotly_brushing\", \"plotly_click\"],\n        plotly_unhover: [\"plotly_hover\"],\n        plotly_doubleclick: [\"plotly_click\"]\n      };\n    \n      Object.keys(eventClearMap).map(function(evt) {\n        graphDiv.on(evt, function() {\n          var inputsToClear = eventClearMap[evt];\n          inputsToClear.map(function(input) {\n            Shiny.setInputValue(input + \"-\" + x.source, null, {priority: \"event\"});\n          });\n        });\n      });\n      \n      var eventDataFunctionMap = {\n        plotly_click: eventDataWithKey,\n        plotly_sunburstclick: eventDataWithKey,\n        plotly_hover: eventDataWithKey,\n        plotly_unhover: eventDataWithKey,\n        // If 'plotly_selected' has already been fired, and you click\n        // on the plot afterwards, this event fires `undefined`?!?\n        // That might be considered a plotly.js bug, but it doesn't make \n        // sense for this input change to occur if `d` is falsy because,\n        // even in the empty selection case, `d` is truthy (an object),\n        // and the 'plotly_deselect' event will reset this input\n        plotly_selected: function(d) { if (d) { return eventDataWithKey(d); } },\n        plotly_selecting: function(d) { if (d) { return eventDataWithKey(d); } },\n        plotly_brushed: function(d) {\n          if (d) { return d.range ? d.range : d.lassoPoints; }\n        },\n        plotly_brushing: function(d) {\n          if (d) { return d.range ? d.range : d.lassoPoints; }\n        },\n        plotly_legendclick: legendEventData,\n        plotly_legenddoubleclick: legendEventData,\n        plotly_clickannotation: function(d) { return d.fullAnnotation }\n      };\n      \n      var registerShinyValue = function(event) {\n        var eventDataPreProcessor = eventDataFunctionMap[event] || function(d) { return d ? d : el.id };\n        // some events are unique to the R package\n        var plotlyJSevent = (event == \"plotly_brushed\") ? \"plotly_selected\" : (event == \"plotly_brushing\") ? \"plotly_selecting\" : event;\n        // register the event\n        graphDiv.on(plotlyJSevent, function(d) {\n          Shiny.setInputValue(\n            event + \"-\" + x.source,\n            JSON.stringify(eventDataPreProcessor(d)),\n            {priority: \"event\"}\n          );\n        });\n      }\n    \n      var shinyEvents = x.shinyEvents || [];\n      shinyEvents.map(registerShinyValue);\n    }\n    \n    // Given an array of {curveNumber: x, pointNumber: y} objects,\n    // return a hash of {\n    //   set1: {value: [key1, key2, ...], _isSimpleKey: false}, \n    //   set2: {value: [key3, key4, ...], _isSimpleKey: false}\n    // }\n    function pointsToKeys(points) {\n      var keysBySet = {};\n      for (var i = 0; i < points.length; i++) {\n        \n        var trace = graphDiv.data[points[i].curveNumber];\n        if (!trace.key || !trace.set) {\n          continue;\n        }\n        \n        // set defaults for this keySet\n        // note that we don't track the nested property (yet) since we always \n        // emit the union -- http://cpsievert.github.io/talks/20161212b/#21\n        keysBySet[trace.set] = keysBySet[trace.set] || {\n          value: [],\n          _isSimpleKey: trace._isSimpleKey\n        };\n        \n        // Use pointNumber by default, but aggregated traces should emit pointNumbers\n        var ptNum = points[i].pointNumber;\n        var hasPtNum = typeof ptNum === \"number\";\n        var ptNum = hasPtNum ? ptNum : points[i].pointNumbers;\n        \n        // selecting a point of a \"simple\" trace means: select the \n        // entire key attached to this trace, which is useful for,\n        // say clicking on a fitted line to select corresponding observations \n        var key = trace._isSimpleKey ? trace.key : Array.isArray(ptNum) ? ptNum.map(function(idx) { return trace.key[idx]; }) : trace.key[ptNum];\n        // http://stackoverflow.com/questions/10865025/merge-flatten-an-array-of-arrays-in-javascript\n        var keyFlat = trace._isNestedKey ? [].concat.apply([], key) : key;\n        \n        // TODO: better to only add new values?\n        keysBySet[trace.set].value = keysBySet[trace.set].value.concat(keyFlat);\n      }\n      \n      return keysBySet;\n    }\n    \n    \n    x.highlight.color = x.highlight.color || [];\n    // make sure highlight color is an array\n    if (!Array.isArray(x.highlight.color)) {\n      x.highlight.color = [x.highlight.color];\n    }\n\n    var traceManager = new TraceManager(graphDiv, x.highlight);\n\n    // Gather all *unique* sets.\n    var allSets = [];\n    for (var curveIdx = 0; curveIdx < x.data.length; curveIdx++) {\n      var newSet = x.data[curveIdx].set;\n      if (newSet) {\n        if (allSets.indexOf(newSet) === -1) {\n          allSets.push(newSet);\n        }\n      }\n    }\n\n    // register event listeners for all sets\n    for (var i = 0; i < allSets.length; i++) {\n      \n      var set = allSets[i];\n      var selection = new crosstalk.SelectionHandle(set);\n      var filter = new crosstalk.FilterHandle(set);\n      \n      var filterChange = function(e) {\n        removeBrush(el);\n        traceManager.updateFilter(set, e.value);\n      };\n      filter.on(\"change\", filterChange);\n      \n      \n      var selectionChange = function(e) {\n        \n        // Workaround for 'plotly_selected' now firing previously selected\n        // points (in addition to new ones) when holding shift key. In our case,\n        // we just want the new keys \n        if (x.highlight.on === \"plotly_selected\" && x.highlight.persistentShift) {\n          // https://stackoverflow.com/questions/1187518/how-to-get-the-difference-between-two-arrays-in-javascript\n          Array.prototype.diff = function(a) {\n              return this.filter(function(i) {return a.indexOf(i) < 0;});\n          };\n          e.value = e.value.diff(e.oldValue);\n        }\n        \n        // array of \"event objects\" tracking the selection history\n        // this is used to avoid adding redundant selections\n        var selectionHistory = crosstalk.var(\"plotlySelectionHistory\").get() || [];\n        \n        // Construct an event object \"defining\" the current event. \n        var event = {\n          receiverID: traceManager.gd.id,\n          plotlySelectionColour: crosstalk.group(set).var(\"plotlySelectionColour\").get()\n        };\n        event[set] = e.value;\n        // TODO: is there a smarter way to check object equality?\n        if (selectionHistory.length > 0) {\n          var ev = JSON.stringify(event);\n          for (var i = 0; i < selectionHistory.length; i++) {\n            var sel = JSON.stringify(selectionHistory[i]);\n            if (sel == ev) {\n              return;\n            }\n          }\n        }\n        \n        // accumulate history for persistent selection\n        if (!x.highlight.persistent) {\n          selectionHistory = [event];\n        } else {\n          selectionHistory.push(event);\n        }\n        crosstalk.var(\"plotlySelectionHistory\").set(selectionHistory);\n        \n        // do the actual updating of traces, frames, and the selectize widget\n        traceManager.updateSelection(set, e.value);\n        // https://github.com/selectize/selectize.js/blob/master/docs/api.md#methods_items\n        if (x.selectize) {\n          if (!x.highlight.persistent || e.value === null) {\n            selectize.clear(true);\n          }\n          selectize.addItems(e.value, true);\n          selectize.close();\n        }\n      }\n      selection.on(\"change\", selectionChange);\n      \n      // Set a crosstalk variable selection value, triggering an update\n      var turnOn = function(e) {\n        if (e) {\n          var selectedKeys = pointsToKeys(e.points);\n          // Keys are group names, values are array of selected keys from group.\n          for (var set in selectedKeys) {\n            if (selectedKeys.hasOwnProperty(set)) {\n              selection.set(selectedKeys[set].value, {sender: el});\n            }\n          }\n        }\n      };\n      if (x.highlight.debounce > 0) {\n        turnOn = debounce(turnOn, x.highlight.debounce);\n      }\n      graphDiv.on(x.highlight.on, turnOn);\n      \n      graphDiv.on(x.highlight.off, function turnOff(e) {\n        // remove any visual clues\n        removeBrush(el);\n        // remove any selection history\n        crosstalk.var(\"plotlySelectionHistory\").set(null);\n        // trigger the actual removal of selection traces\n        selection.set(null, {sender: el});\n      });\n          \n      // register a callback for selectize so that there is bi-directional\n      // communication between the widget and direct manipulation events\n      if (x.selectize) {\n        var selectizeID = Object.keys(x.selectize)[i];\n        var items = x.selectize[selectizeID].items;\n        var first = [{value: \"\", label: \"(All)\"}];\n        var opts = {\n          options: first.concat(items),\n          searchField: \"label\",\n          valueField: \"value\",\n          labelField: \"label\",\n          maxItems: 50\n        };\n        var select = $(\"#\" + selectizeID).find(\"select\")[0];\n        var selectize = $(select).selectize(opts)[0].selectize;\n        // NOTE: this callback is triggered when *directly* altering \n        // dropdown items\n        selectize.on(\"change\", function() {\n          var currentItems = traceManager.groupSelections[set] || [];\n          if (!x.highlight.persistent) {\n            removeBrush(el);\n            for (var i = 0; i < currentItems.length; i++) {\n              selectize.removeItem(currentItems[i], true);\n            }\n          }\n          var newItems = selectize.items.filter(function(idx) { \n            return currentItems.indexOf(idx) < 0;\n          });\n          if (newItems.length > 0) {\n            traceManager.updateSelection(set, newItems);\n          } else {\n            // Item has been removed...\n            // TODO: this logic won't work for dynamically changing palette \n            traceManager.updateSelection(set, null);\n            traceManager.updateSelection(set, selectize.items);\n          }\n        });\n      }\n    } // end of selectionChange\n\n    graphDiv.on(\"plotly_afterplot\", function() {\n      // Used by Displayr to determine when widget is ready to be snapshot for testing\n      graphDiv.setAttribute(\"rhtmlwidget-status\", \"ready\");\n    });\n  } // end of renderValue\n}; // end of widget definition\n\n/**\n * @param graphDiv The Plotly graph div\n * @param highlight An object with options for updating selection(s)\n */\nfunction TraceManager(graphDiv, highlight) {\n  // The Plotly graph div\n  this.gd = graphDiv;\n\n  // Preserve the original data.\n  // TODO: try using Lib.extendFlat() as done in  \n  // https://github.com/plotly/plotly.js/pull/1136 \n  this.origData = JSON.parse(JSON.stringify(graphDiv.data));\n  \n  // avoid doing this over and over\n  this.origOpacity = [];\n  for (var i = 0; i < this.origData.length; i++) {\n    this.origOpacity[i] = this.origData[i].opacity === 0 ? 0 : (this.origData[i].opacity || 1);\n  }\n\n  // key: group name, value: null or array of keys representing the\n  // most recently received selection for that group.\n  this.groupSelections = {};\n  \n  // selection parameters (e.g., transient versus persistent selection)\n  this.highlight = highlight;\n}\n\nTraceManager.prototype.close = function() {\n  // TODO: Unhook all event handlers\n};\n\nTraceManager.prototype.updateFilter = function(group, keys) {\n\n  if (typeof(keys) === \"undefined\" || keys === null) {\n    \n    this.gd.data = JSON.parse(JSON.stringify(this.origData));\n    \n  } else {\n  \n    var traces = [];\n    for (var i = 0; i < this.origData.length; i++) {\n      var trace = this.origData[i];\n      if (!trace.key || trace.set !== group) {\n        continue;\n      }\n      var matchFunc = getMatchFunc(trace);\n      var matches = matchFunc(trace.key, keys);\n      \n      if (matches.length > 0) {\n        if (!trace._isSimpleKey) {\n          // subsetArrayAttrs doesn't mutate trace (it makes a modified clone)\n          trace = subsetArrayAttrs(trace, matches);\n        }\n        traces.push(trace);\n      }\n    }\n    this.gd.data = traces;\n  }\n  \n  Plotly.redraw(this.gd);\n  \n  // NOTE: we purposely do _not_ restore selection(s), since on filter,\n  // axis likely will update, changing the pixel -> data mapping, leading \n  // to a likely mismatch in the brush outline and highlighted marks\n  \n};\n\nTraceManager.prototype.updateSelection = function(group, keys) {\n  \n  if (keys !== null && !Array.isArray(keys)) {\n    throw new Error(\"Invalid keys argument; null or array expected\");\n  }\n  \n  // if selection has been cleared, or if this is transient\n  // selection, delete the \"selection traces\"\n  var nNewTraces = this.gd.data.length - this.origData.length;\n  if (keys === null || !this.highlight.persistent && nNewTraces > 0) {\n    var tracesToRemove = [];\n    for (var i = 0; i < this.gd.data.length; i++) {\n      if (this.gd.data[i]._isCrosstalkTrace) tracesToRemove.push(i);\n    }\n    Plotly.deleteTraces(this.gd, tracesToRemove);\n    this.groupSelections[group] = keys;\n  } else {\n    // add to the groupSelection, rather than overwriting it\n    // TODO: can this be removed?\n    this.groupSelections[group] = this.groupSelections[group] || [];\n    for (var i = 0; i < keys.length; i++) {\n      var k = keys[i];\n      if (this.groupSelections[group].indexOf(k) < 0) {\n        this.groupSelections[group].push(k);\n      }\n    }\n  }\n  \n  if (keys === null) {\n    \n    Plotly.restyle(this.gd, {\"opacity\": this.origOpacity});\n    \n  } else if (keys.length >= 1) {\n    \n    // placeholder for new \"selection traces\"\n    var traces = [];\n    // this variable is set in R/highlight.R\n    var selectionColour = crosstalk.group(group).var(\"plotlySelectionColour\").get() || \n      this.highlight.color[0];\n\n    for (var i = 0; i < this.origData.length; i++) {\n      // TODO: try using Lib.extendFlat() as done in  \n      // https://github.com/plotly/plotly.js/pull/1136 \n      var trace = JSON.parse(JSON.stringify(this.gd.data[i]));\n      if (!trace.key || trace.set !== group) {\n        continue;\n      }\n      // Get sorted array of matching indices in trace.key\n      var matchFunc = getMatchFunc(trace);\n      var matches = matchFunc(trace.key, keys);\n      \n      if (matches.length > 0) {\n        // If this is a \"simple\" key, that means select the entire trace\n        if (!trace._isSimpleKey) {\n          trace = subsetArrayAttrs(trace, matches);\n        }\n        // reach into the full trace object so we can properly reflect the \n        // selection attributes in every view\n        var d = this.gd._fullData[i];\n        \n        /* \n        / Recursively inherit selection attributes from various sources, \n        / in order of preference:\n        /  (1) official plotly.js selected attribute\n        /  (2) highlight(selected = attrs_selected(...))\n        */\n        // TODO: it would be neat to have a dropdown to dynamically specify these!\n        $.extend(true, trace, this.highlight.selected);\n        \n        // if it is defined, override color with the \"dynamic brush color\"\"\n        if (d.marker) {\n          trace.marker = trace.marker || {};\n          trace.marker.color =  selectionColour || trace.marker.color || d.marker.color;\n        }\n        if (d.line) {\n          trace.line = trace.line || {};\n          trace.line.color =  selectionColour || trace.line.color || d.line.color;\n        }\n        if (d.textfont) {\n          trace.textfont = trace.textfont || {};\n          trace.textfont.color =  selectionColour || trace.textfont.color || d.textfont.color;\n        }\n        if (d.fillcolor) {\n          // TODO: should selectionColour inherit alpha from the existing fillcolor?\n          trace.fillcolor = selectionColour || trace.fillcolor || d.fillcolor;\n        }\n        // attach a sensible name/legendgroup\n        trace.name = trace.name || keys.join(\"<br />\");\n        trace.legendgroup = trace.legendgroup || keys.join(\"<br />\");\n        \n        // keep track of mapping between this new trace and the trace it targets\n        // (necessary for updating frames to reflect the selection traces)\n        trace._originalIndex = i;\n        trace._newIndex = this.gd._fullData.length + traces.length;\n        trace._isCrosstalkTrace = true;\n        traces.push(trace);\n      }\n    }\n    \n    if (traces.length > 0) {\n      \n      Plotly.addTraces(this.gd, traces).then(function(gd) {\n        // incrementally add selection traces to frames\n        // (this is heavily inspired by Plotly.Plots.modifyFrames() \n        // in src/plots/plots.js)\n        var _hash = gd._transitionData._frameHash;\n        var _frames = gd._transitionData._frames || [];\n        \n        for (var i = 0; i < _frames.length; i++) {\n          \n          // add to _frames[i].traces *if* this frame references selected trace(s)\n          var newIndices = [];\n          for (var j = 0; j < traces.length; j++) {\n            var tr = traces[j];\n            if (_frames[i].traces.indexOf(tr._originalIndex) > -1) {\n              newIndices.push(tr._newIndex);\n              _frames[i].traces.push(tr._newIndex);\n            }\n          }\n          \n          // nothing to do...\n          if (newIndices.length === 0) {\n            continue;\n          }\n          \n          var ctr = 0;\n          var nFrameTraces = _frames[i].data.length;\n          \n          for (var j = 0; j < nFrameTraces; j++) {\n            var frameTrace = _frames[i].data[j];\n            if (!frameTrace.key || frameTrace.set !== group) {\n              continue;\n            }\n            \n            var matchFunc = getMatchFunc(frameTrace);\n            var matches = matchFunc(frameTrace.key, keys);\n            \n            if (matches.length > 0) {\n              if (!trace._isSimpleKey) {\n                frameTrace = subsetArrayAttrs(frameTrace, matches);\n              }\n              var d = gd._fullData[newIndices[ctr]];\n              if (d.marker) {\n                frameTrace.marker = d.marker;\n              }\n              if (d.line) {\n                frameTrace.line = d.line;\n              }\n              if (d.textfont) {\n                frameTrace.textfont = d.textfont;\n              }\n              ctr = ctr + 1;\n              _frames[i].data.push(frameTrace);\n            }\n          }\n          \n          // update gd._transitionData._frameHash\n          _hash[_frames[i].name] = _frames[i];\n        }\n      \n      });\n      \n      // dim traces that have a set matching the set of selection sets\n      var tracesToDim = [],\n          opacities = [],\n          sets = Object.keys(this.groupSelections),\n          n = this.origData.length;\n          \n      for (var i = 0; i < n; i++) {\n        var opacity = this.origOpacity[i] || 1;\n        // have we already dimmed this trace? Or is this even worth doing?\n        if (opacity !== this.gd._fullData[i].opacity || this.highlight.opacityDim === 1) {\n          continue;\n        }\n        // is this set an element of the set of selection sets?\n        var matches = findMatches(sets, [this.gd.data[i].set]);\n        if (matches.length) {\n          tracesToDim.push(i);\n          opacities.push(opacity * this.highlight.opacityDim);\n        }\n      }\n      \n      if (tracesToDim.length > 0) {\n        Plotly.restyle(this.gd, {\"opacity\": opacities}, tracesToDim);\n        // turn off the selected/unselected API\n        Plotly.restyle(this.gd, {\"selectedpoints\": null});\n      }\n      \n    }\n    \n  }\n};\n\n/* \nNote: in all of these match functions, we assume needleSet (i.e. the selected keys)\nis a 1D (or flat) array. The real difference is the meaning of haystack.\nfindMatches() does the usual thing you'd expect for \nlinked brushing on a scatterplot matrix. findSimpleMatches() returns a match iff \nhaystack is a subset of the needleSet. findNestedMatches() returns \n*/\n\nfunction getMatchFunc(trace) {\n  return (trace._isNestedKey) ? findNestedMatches : \n    (trace._isSimpleKey) ? findSimpleMatches : findMatches;\n}\n\n// find matches for \"flat\" keys\nfunction findMatches(haystack, needleSet) {\n  var matches = [];\n  haystack.forEach(function(obj, i) {\n    if (obj === null || needleSet.indexOf(obj) >= 0) {\n      matches.push(i);\n    }\n  });\n  return matches;\n}\n\n// find matches for \"simple\" keys\nfunction findSimpleMatches(haystack, needleSet) {\n  var match = haystack.every(function(val) {\n    return val === null || needleSet.indexOf(val) >= 0;\n  });\n  // yes, this doesn't make much sense other than conforming \n  // to the output type of the other match functions\n  return (match) ? [0] : []\n}\n\n// find matches for a \"nested\" haystack (2D arrays)\nfunction findNestedMatches(haystack, needleSet) {\n  var matches = [];\n  for (var i = 0; i < haystack.length; i++) {\n    var hay = haystack[i];\n    var match = hay.every(function(val) { \n      return val === null || needleSet.indexOf(val) >= 0; \n    });\n    if (match) {\n      matches.push(i);\n    }\n  }\n  return matches;\n}\n\nfunction isPlainObject(obj) {\n  return (\n    Object.prototype.toString.call(obj) === '[object Object]' &&\n    Object.getPrototypeOf(obj) === Object.prototype\n  );\n}\n\nfunction inIframe() {\n  return window && window.self !== window.top;\n}\n\nfunction subsetArrayAttrs(obj, indices) {\n  var newObj = {};\n  Object.keys(obj).forEach(function(k) {\n    var val = obj[k];\n\n    if (k.charAt(0) === \"_\") {\n      newObj[k] = val;\n    } else if (k === \"transforms\" && Array.isArray(val)) {\n      newObj[k] = val.map(function(transform) {\n        return subsetArrayAttrs(transform, indices);\n      });\n    } else if (k === \"colorscale\" && Array.isArray(val)) {\n      newObj[k] = val;\n    } else if (isPlainObject(val)) {\n      newObj[k] = subsetArrayAttrs(val, indices);\n    } else if (Array.isArray(val)) {\n      newObj[k] = subsetArray(val, indices);\n    } else {\n      newObj[k] = val;\n    }\n  });\n  return newObj;\n}\n\nfunction subsetArray(arr, indices) {\n  var result = [];\n  for (var i = 0; i < indices.length; i++) {\n    result.push(arr[indices[i]]);\n  }\n  return result;\n}\n\n// Convenience function for removing plotly's brush \nfunction removeBrush(el) {\n  var outlines = el.querySelectorAll(\".select-outline\");\n  for (var i = 0; i < outlines.length; i++) {\n    outlines[i].remove();\n  }\n}\n\n\n// https://davidwalsh.name/javascript-debounce-function\n\n// Returns a function, that, as long as it continues to be invoked, will not\n// be triggered. The function will be called after it stops being called for\n// N milliseconds. If `immediate` is passed, trigger the function on the\n// leading edge, instead of the trailing.\nfunction debounce(func, wait, immediate) {\n  var timeout;\n  return function() {\n    var context = this, args = arguments;\n    var later = function() {\n      timeout = null;\n      if (!immediate) func.apply(context, args);\n    };\n    var callNow = immediate && !timeout;\n    clearTimeout(timeout);\n    timeout = setTimeout(later, wait);\n    if (callNow) func.apply(context, args);\n  };\n};\n\nmodule.exports = widgetDefinition"]}